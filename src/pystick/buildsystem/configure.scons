# -*- python -*-
import platform

import confutils
import cenv

from utils import is_building

Import('env')


if env['PLATFORM'] == 'posix':  # posix is a platform SCons sets, but we want more details (hint: linux?)
    print("PLATFORM is set to 'posix', using sys.platform() to get better details")
    import sys
    env['PLATFORM'] = sys.platform

if 'PLATFORM_RELEASE' not in env:
    print("PLATFORM_RELEASE not set, using platform.release() to get it.")
    env['PLATFORM_RELEASE'] = platform.release()

AVAILABLE_PLATFORMS = ('cygwin', 'irix', 'os2', 'aix', 'darwin', 'sunos', 'linux2', 'hpux', 'win32')
if env['PLATFORM'] not in AVAILABLE_PLATFORMS:
    from SCons.Errors import UserError
    raise UserError("PLATFORM is set to {!r}, but it needs to be on of {!r}".format(env['PLATFORM'], AVAILABLE_PLATFORMS))

if not env['TARGET_ARCH']:
    print("TARGET_ARCH not set, using platform.architecture() to get it.")
    env['TARGET_ARCH'] = 'x86' if platform.architecture()[0] in ('32bit', 'n32bit') else 'amd64'

is_32bit = env['TARGET_ARCH'] == 'x86'
is_64bit = env['TARGET_ARCH'] == 'amd64'

if not (is_32bit or is_64bit):
    import pdb;  pdb.set_trace()
    raise Exception("Don't know what to make out of TARGET_ARCH {} - not 32bit and not 64bit.".format(env['TARGET_ARCH']))

# We expect the following env variables to be defined:
# PLATFORM - cygwin, irix, os2, aix, darwin, sunos, linux2, hpux, win32
# PLATFORM_RELEASE - 5.8, 5.6, etc. (depending on PLATFORM)
# For cross compiling, you have to manually determine the following (basically all defines that are generated by a
# CheckCRuns() call):
#
# X87_DOUBLE_ROUNDING
# GETPGRP_HAVE_ARG
# SETPGRP_HAVE_ARG
# HAVE_BROKEN_NICE
# HAVE_BROKEN_POLL
# HAVE_GETC_UNLOCKED
# HAVE_GETADDRINFO (checking for buggy getaddrinfo)
# TANH_PRESERVES_ZERO_SIGN
# PTHREAD_SYSTEM_SCHED_SUPPORTED
# HAVE_WORKING_TZSET
# Unicode support (HAVE_USABLE_WCHAR_T PY_UNICODE_TYPE)


def sanity_test(config):
    code = """
#include <stdio.h>
int main() {
    printf("hello, world.\\n");
    return 0;
}
"""
    return config.CheckCRuns("Hello world sanity test to see that the compiler and linker are ok... ", code)


def check_double(config, name, encoding):
    code = """
#include <string.h>
int main() {
    double x = 9006104071832581.0;
    return memcmp(&x, ENCODING, 8) == 0 ? 0 : 1;
}
"""
    return config.CheckCRuns('Checking if double is {}... '.format(name), code.replace('ENCODING', encoding))


def check_double_is_little_endian_ieee754(config):
    return check_double(config, 'little endian IEEE754', r'"\x05\x04\x03\x02\x01\xff\x3f\x43"')


def check_double_is_big_endian_ieee754(config):
    return check_double(config, 'big endian IEEE754', r'"\x43\x3f\xff\x01\x02\x03\x04\x05"')


def check_double_is_arm_mixed_endian_ieee754(config):
    return check_double(config, 'ARM mixed endian IEEE754', r'"\x01\xff\x3f\x43\x05\x04\x03\x02"')


def check_pgrp_have_arg(config):
    code = "#include <unistd.h>\nint main() {\ngetpgrp(0);\nreturn 0;}"
    return config.CheckCRuns('Checking if getpgrp requires an argument... ', code)


def check_setpgrp_have_arg(config):
    code = "#include <unistd.h>\nint main() { setpgrp(0,0); return 0; }"
    return config.CheckCRuns('Checking if setpgrp requires an argument... ', code)


def check_gettimeofday_has_tz(config):
    code = "#include <sys/time.h>\nint main() {gettimeofday((struct timeval*)0,(struct timezone*)0);}"
    return config.CheckCCompiles('Checking if gettimeofday has tz... ', code)


def check_nice_broken(config):
    code = "#include <unistd.h>\nint main() {\nreturn nice(2) == 2 ? 1 : 0;\n}"
    return config.CheckCRuns('Checking if nice() is broken... ', code)


def check_poll_broken(config):
    code = """
 #include <poll.h>
int main () {
    struct pollfd poll_struct = { 42, POLLIN|POLLPRI|POLLOUT, 0 };
    close(42);
    int poll_test = poll(&poll_struct, 1, 0);
    if (poll_test < 0) {
        return 0;
    } else if (poll_test == 0 && poll_struct.revents != POLLNVAL) {
        return 0;
    } else {
        return 1;
    }
}
"""
    return config.CheckCRuns('Checking if poll() is broken... ', code)


def check_getaddrinfo(config):
    getaddrinfo_code = """
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>

int main() {
    getaddrinfo(NULL, NULL, NULL, NULL);
    return 0;
}
"""
    buggy_getaddrinfo_code = """
#include <stdio.h>
#include <sys/types.h>
#include <netdb.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
  int passive, gaierr, inet4 = 0, inet6 = 0;
  struct addrinfo hints, *ai, *aitop;
  char straddr[INET6_ADDRSTRLEN], strport[16];

  for (passive = 0; passive <= 1; passive++) {
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_flags = passive ? AI_PASSIVE : 0;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    if ((gaierr = getaddrinfo(NULL, "54321", &hints, &aitop)) != 0) {
      (void)gai_strerror(gaierr);
      goto bad;
    }
    for (ai = aitop; ai; ai = ai->ai_next) {
      if (ai->ai_addr == NULL ||
          ai->ai_addrlen == 0 ||
          getnameinfo(ai->ai_addr, ai->ai_addrlen,
                      straddr, sizeof(straddr), strport, sizeof(strport),
                      NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
        goto bad;
      }
      switch (ai->ai_family) {
      case AF_INET:
        if (strcmp(strport, "54321") != 0) {
          goto bad;
        }
        if (passive) {
          if (strcmp(straddr, "0.0.0.0") != 0) {
            goto bad;
          }
        } else {
          if (strcmp(straddr, "127.0.0.1") != 0) {
            goto bad;
          }
        }
        inet4++;
        break;
      case AF_INET6:
        if (strcmp(strport, "54321") != 0) {
          goto bad;
        }
        if (passive) {
          if (strcmp(straddr, "::") != 0) {
            goto bad;
          }
        } else {
          if (strcmp(straddr, "::1") != 0) {
            goto bad;
          }
        }
        inet6++;
        break;
      case AF_UNSPEC:
        goto bad;
        break;
      default:
        /* another family support? */
        break;
      }
    }
  }

  if (!(inet4 == 0 || inet4 == 2))
    goto bad;
  if (!(inet6 == 0 || inet6 == 2))
    goto bad;

  if (aitop)
    freeaddrinfo(aitop);
  return 0;

 bad:
  if (aitop)
    freeaddrinfo(aitop);
  return 1;
}
"""
    if config.CheckCLinks("Checking for getaddrinfo()... ", getaddrinfo_code):
        if config.CheckCRuns("Checking for buggy getaddrinfo()... ", buggy_getaddrinfo_code):
            return True
    return False


def check_gcc_asm_for_x87(config):
    code = """
int main() {
  unsigned short cw;
  __asm__ __volatile__ ("fnstcw %0" : "=m" (cw));
  __asm__ __volatile__ ("fldcw %0" : : "m" (cw));
  return 0;
}
"""
    return config.CheckCCompiles('Checking whether we can use gcc inline assembler to get and set x87 control word... ', code)


def check_x87_double_rounding(config):
    code = """
#include <stdlib.h>
#include <math.h>
int main() {
    volatile double x, y, z;
    /* 1./(1-2**-53) -> 1+2**-52 (correct), 1.0 (double rounding) */
    x = 0.99999999999999989; /* 1-2**-53 */
    y = 1./x;
    if (y != 1.)
        exit(0);
    /* 1e16+2.99999 -> 1e16+2. (correct), 1e16+4. (double rounding) */
    x = 1e16;
    y = 2.99999;
    z = x + y;
    if (z != 1e16+4.)
        exit(0);
    /* both tests show evidence of double rounding */
    exit(1);
}
"""
    return not config.CheckCRuns('Checking for x87-style double rounding... ', code)

def check_getc_unlocked(config):
    code = """
#include <stdio.h>
int main() {
    FILE *f = fopen("/dev/null", "r");
    flockfile(f);
    getc_unlocked(f);
    funlockfile(f);
    return 0;
}
"""
    return config.CheckCRuns('Checking for getc_unlocked() and friends... ', code)


def check_volatile(config):
    code = "int main() { volatile int x; x = 0; return 0; }"
    return config.CheckCCompiles("Checking for working volatile... ", code)


def check_char_unsigned(config):
    code = """
int main() {
    static int test_array [1 - 2 * !(((char) -1) < 0)];
    test_array [0] = 0;
    return test_array[0];
}
"""
    return not config.CheckCCompiles('Checking if char is unsigned... ', code)


def check_sys_select_with_sys_time_is_ok(config):
    code = """
#include <sys/types.h>
#include <sys/select.h>
#include <sys/time.h>
int main() {
    return 0;
}
"""
    return config.CheckCCompiles('whether sys/select.h and sys/time.h may both be included... ', code)


def check_tanh_preserves_zero_sign(config):
    code = """
#include <math.h>
#include <stdlib.h>
int main() {
    /* return 0 if either negative zeros don't exist on this platform or if negative zeros exist and tanh(-0.) == -0. */
    if (atan2(0., -1.) == atan2(-0., -1.) || atan2(tanh(-0.), -1.) == atan2(-0., -1.))
        exit(0);
    else
        exit(1);
}
"""
    return config.CheckCRuns('whether tanh preserves the sign of zero... ', code)


def check_time_with_sys_time_is_ok(config):
    code = """
#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
int main() {
    if ((struct tm *) 0) return 0;
    return 0;
}
"""
    return config.CheckCCompiles('Checking whether time.h and sys/time.h may both be included...', code)


def check_va_list_is_array(config):
    code = """
#ifdef HAVE_STDARG_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
int main() {
    va_list list1, list2; list1 = list2;
    return 0;
}
"""
    return config.CheckCCompiles('Checking whether va_list is an array... ', code)


def check_pthread_scope_system_supported(config):
    code = """
#include <stdio.h>
#include <pthread.h>
void *foo(void *parm) {
    return NULL;
}
main() {
    pthread_attr_t attr;
    pthread_t id;
    if (pthread_attr_init(&attr)) exit(-1);
    if (pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM)) exit(-1);
    if (pthread_create(&id, &attr, foo, NULL)) exit(-1);
    exit(0);
}
"""
    return config.CheckCRuns('Checking if PTHREAD_SCOPE_SYSTEM is supported... ', code)


def check_solaris_lfs_no_bug(config):
    # Enabling LFS on Solaris (2.6 to 9) with gcc 2.95 triggers a bug in
    # the system headers: If _XOPEN_SOURCE and _LARGEFILE_SOURCE are
    # defined, but the compiler does not support pragma redefine_extname,
    # and _LARGEFILE64_SOURCE is not defined, the headers refer to 64-bit
    # structures (such as rlimit64) without declaring them. As a
    # work-around, disable LFS on such configurations
    code = """
#define _LARGEFILE_SOURCE 1
#define _FILE_OFFSET_BITS 64
#include <sys/resource.h>
int main() {
    struct rlimit foo;
    return 0;
}
"""
    return config.CheckCCompiles('Checking no Solaris LFS bug... ', code)


def check_safe_to_define__extensions__(config, includes):
    code = """
#define __EXTENSIONS__ 1
%(includes)s
int main() { return 0; }
"""
    return config.CheckCCompiles('Checking whether it is safe to define __EXTENSIONS__... ',
                                 code % dict(includes=includes))


def check_tzname(config):
    code = """
#include <time.h>
#if !HAVE_DECL_TZNAME
extern char *tzname[];
#endif

int main() { return tzname[0][0]; }
"""
    return config.CheckCCompiles('Checking if we have tzname()... ', code)


def check_ansi_c_conforming_const(config):
    code = """
int
main ()
{

#ifndef __cplusplus
  /* Ultrix mips cc rejects this sort of thing.  */
  typedef int charset[2];
  const charset cs = { 0, 0 };
  /* SunOS 4.1.1 cc rejects this.  */
  char const *const *pcpcc;
  char **ppc;
  /* NEC SVR4.0.2 mips cc rejects this.  */
  struct point {int x, y;};
  static struct point const zero = {0,0};
  /* AIX XL C 1.02.0.0 rejects this.
     It does not let you subtract one const X* pointer from another in
     an arm of an if-expression whose if-part is not a constant
     expression */
  const char *g = "string";
  pcpcc = &g + (g ? g-g : 0);
  /* HPUX 7.0 cc rejects these. */
  ++pcpcc;
  ppc = (char**) pcpcc;
  pcpcc = (char const *const *) ppc;
  { /* SCO 3.2v4 cc rejects this sort of thing.  */
    char tx;
    char *t = &tx;
    char const *s = 0 ? (char *) 0 : (char const *) 0;

    *t++ = 0;
    if (s) return 0;
  }
  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
    int x[] = {25, 17};
    const int *foo = &x[0];
    ++foo;
  }
  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
    typedef const int *iptr;
    iptr p = 0;
    ++p;
  }
  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
    struct s { int j; const int *ap[3]; } bx;
    struct s *b = &bx; b->j = 5;
  }
  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
    const int foo = 10;
    if (!foo) return 0;
  }
  return !cs[0] && !zero.x;
#endif

  ;
  return 0;
}
"""
    return config.CheckCCompiles('Checking for an ANSI C-conforming const... ', code)


def check_stdarg_prototypes(config):
    code = """
#include <stdarg.h>
int foo(int x, ...) {
    va_list va;
    va_start(va, x);
    va_arg(va, int);
    va_arg(va, char *);
    va_arg(va, double);
    return 0;
}

int main() {
    return foo(10, "", 3.14);
}
"""
    return config.CheckCCompiles('Checking for variable length prototypes and stdarg.h... ', code)


def check_gethostbyname_r_6_arg(config):
    code = """
#include <netdb.h>

int main() {
    char *name;
    struct hostent *he, *res;
    char buffer[2048];
    int buflen = 2048;
    int h_errnop;

    (void) gethostbyname_r(name, he, buffer, buflen, &res, &h_errnop);
    return 0;
}
"""
    return config.CheckCCompiles('Checking for gethostbyname_r with 6 arguments... ', code)


def check_gethostbyname_r_5_arg(config):
    code = """
#include <netdb.h>

int main() {
    char *name;
    struct hostent *he;
    char buffer[2048];
    int buflen = 2048;
    int h_errnop;

    (void) gethostbyname_r(name, he, buffer, buflen, &h_errnop)
    return 0;
"""
    return config.CheckCCompiles('Checking for gethostbyname_r with 5 arguments... ', code)


def check_gethostbyname_r_3_arg(config):
    code = """
#include <netdb.h>

int main() {
    char *name;
    struct hostent *he;
    struct hostent_data data;

    (void) gethostbyname_r(name, he, &data);
    return 0;
"""
    return config.CheckCCompiles('Checking for gethostbyname_r with 3 arguments... ', code)


def check_compiler_prototypes(config):
    code = """
int foo(int x) { return 0; }
int main() {
    return foo(10);
}
"""
    return config.CheckCCompiles('Checking for prototypes... ', code)


def check_working_tzset(config):
    code = """
#include <stdlib.h>
#include <time.h>
#include <string.h>

#if HAVE_TZNAME
extern char *tzname[];
#endif

int main()
{
    /* Note that we need to ensure that not only does tzset(3)
       do 'something' with localtime, but it works as documented
       in the library reference and as expected by the test suite.
       This includes making sure that tzname is set properly if
       tm->tm_zone does not exist since it is the alternative way
       of getting timezone info.

       Red Hat 6.2 doesn't understand the southern hemisphere
       after New Year's Day.
    */

    time_t groundhogday = 1044144000; /* GMT-based */
    time_t midyear = groundhogday + (365 * 24 * 3600 / 2);

    putenv("TZ=UTC+0");
    tzset();
    if (localtime(&groundhogday)->tm_hour != 0)
        exit(1);
#if HAVE_TZNAME
    /* For UTC, tzname[1] is sometimes "", sometimes "   " */
    if (strcmp(tzname[0], "UTC") ||
        (tzname[1][0] != 0 && tzname[1][0] != ' '))
        exit(1);
#endif

    putenv("TZ=EST+5EDT,M4.1.0,M10.5.0");
    tzset();
    if (localtime(&groundhogday)->tm_hour != 19)
        exit(1);
#if HAVE_TZNAME
    if (strcmp(tzname[0], "EST") || strcmp(tzname[1], "EDT"))
        exit(1);
#endif

    putenv("TZ=AEST-10AEDT-11,M10.5.0,M3.5.0");
    tzset();
    if (localtime(&groundhogday)->tm_hour != 11)
        exit(1);
#if HAVE_TZNAME
    if (strcmp(tzname[0], "AEST") || strcmp(tzname[1], "AEDT"))
        exit(1);
#endif

#if HAVE_STRUCT_TM_TM_ZONE
    if (strcmp(localtime(&groundhogday)->tm_zone, "AEDT"))
        exit(1);
    if (strcmp(localtime(&midyear)->tm_zone, "AEST"))
        exit(1);
#endif

    exit(0);
}
"""
    return config.CheckCRuns('Checking if we have a working tzset()... ', code)


def check_ucs4_tcl(config):
    code = """
#include <tcl.h>
#if TCL_UTF_MAX != 6
# error "NOT UCS4_TCL"
#endif
int main() {
    return 0;
}
"""
    return config.CheckCCompiles('Checking if TCL has UCS4 support... ', code)


def check_working_sem_getvalue(config):
    # Will return True if sem_getvalue is working, False if not.
    code = """
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <semaphore.h>
#include <sys/stat.h>

int main(void){
  sem_t *a = sem_open("/autocftw", O_CREAT, S_IRUSR|S_IWUSR, 0);
  int count;
  int res;
  if(a==SEM_FAILED){
    perror("sem_open");
    return 1;

  }
  res = sem_getvalue(a, &count);
  sem_close(a);
  sem_unlink("/autocftw");
  return res==-1 ? 1 : 0;
}
"""
    return config.CheckCRuns('Checking for working sem_getvalue()... ', code)


def check_osx_10_5_sdk(config):
    code = """
#include <Carbon/Carbon.h>
int main (void) {
    FSIORefNum fRef = 0;
    return 0;
}
"""
    return config.CheckCCompiles('Checking for OSX 10.5 SDK or later... ', code)


def configure():
    defines = dict()
    def add_int_define(key, flag, value=1):
        if flag:
            defines[key] = value
        return flag

    def add_bool_define(key, flag):
        if flag:
            defines[key] = True
        return flag

    configure_log = env.Dir('$BUILD_PATH').File('configure.log')
    config = env.Configure(conf_dir=env.Dir('$BUILD_PATH').Dir('.sconf_temp'),
                           log_file=configure_log,
                           custom_tests=confutils.get_custom_tests_dict())

    # First thing first, let's do a sanity test and see if the compiler and linker (and their flags) can compile and
    # link successfully (i.e. the user didn't pass options that the compiler/linker don't know about).
    if not sanity_test(config):
        raise Exception("Compiler/linker sanity test failed, check {} for more details.".format(configure_log.abspath))

    if config.CheckARResponseFile():
        defines['AR_HAS_RSP'] = 1

    # Check if MINIX:
    if config.CheckHeader('minix/config.h'):
        defines['_MINIX'] = 1
        defines['_POSIX_SOURCE'] = 1
        defines['_POSIX_1_SOURCE'] = 2

    irregular_symbols = dict(is_term_resized='CURSES_IS_TERM_RESIZED',
                             resizeterm='CURSES_RESIZETERM',
                             resize_term='CURSES_RESIZE_TERM',
                             epoll_create='EPOLL')

    def symbol_to_define(sym, prefix='HAVE_', suffix=''):
        return confutils.symbol_to_define(sym, prefix, suffix, irregular_symbols)

    for header in ('alloca.h', 'asm/types.h', 'bluetooth.h', 'bluetooth/bluetooth.h', 'conio.h', 'cthreads.h',
                   'curses.h', 'direct.h',
                   'dlfcn.h', 'errno.h', 'fcntl.h', 'grp.h', 'ieeefp.h', 'inttypes.h', 'io.h', 'langinfo.h',
                   'libintl.h', 'libutil.h', 'linux/netlink.h', 'linux/tipc.h', 'memory.h', 'ncurses.h',
                   'netpacket/packet.h', 'poll.h', 'process.h', 'pthread.h', 'pty.h', 'shadow.h', 'signal.h', 'spawn.h',
                   'stddef.h', 'stdint.h', 'stdlib.h', 'string.h', 'strings.h', 'stropts.h', 'sys/audioio.h',
                   'sys/bsdtty.h', 'sys/epoll.h', 'sys/event.h', 'sys/file.h', 'sys/loadavg.h', 'sys/lock.h',
                   'sys/mkdev.h', 'sys/modem.h', 'sys/param.h', 'sys/poll.h', 'sys/resource.h', 'sys/select.h',
                   'sys/socket.h', 'sys/stat.h', 'sys/statvfs.h', 'sys/termio.h', 'sys/time.h', 'sys/times.h',
                   'sys/types.h', 'sys/un.h', 'sys/utsname.h', 'sys/wait.h', 'sysexits.h', 'term.h', 'termios.h',
                   'thread.h', 'unistd.h', 'util.h', 'utime.h', 'wchar.h'):
        add_int_define(symbol_to_define(header), config.CheckHeader(header))

    # This is based on configure's default includes (with some variation):
    default_headers = ['stdio.h']
    for header in ('sys/types.h', 'sys/stat.h', 'stdlib.h', 'stddef.h', 'memory.h', 'string.h', 'strings.h',
                   'inttypes.h', 'stdint.h', 'unistd.h'):
        if symbol_to_define(header) in defines:
            default_headers.append(header)
    default_includes = "\n".join("#include <{}>".format(header) for header in default_headers)

    if not add_int_define('HAVE_FLOCK', config.CheckFunc('flock')):
        if config.CheckLib('bsd', 'flock'):
            defines['HAVE_FLOCK'] = 1
            defines['FLOCK_NEEDS_LIBBSD'] = True

    if env['DOUBLE_ENDIAN'] == 'auto':
        add_int_define('DOUBLE_IS_LITTLE_ENDIAN_IEEE754', check_double_is_little_endian_ieee754(config))
        add_int_define('DOUBLE_IS_BIG_ENDIAN_IEEE754', check_double_is_big_endian_ieee754(config))
        add_int_define('DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754', check_double_is_arm_mixed_endian_ieee754(config))
    elif env['DOUBLE_ENDIAN'] == 'big':
        add_int_define('DOUBLE_IS_BIG_ENDIAN_IEEE754', True)
    elif env['DOUBLE_ENDIAN'] == 'little':
        add_int_define('DOUBLE_IS_LITTLE_ENDIAN_IEEE754', True)
    elif env['DOUBLE_ENDIAN'] == 'mixed':
        add_int_define('DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754', True)

    add_int_define('GETPGRP_HAVE_ARG', check_pgrp_have_arg(config))
    add_int_define('GETTIMEOFDAY_NO_TZ', not check_gettimeofday_has_tz(config))

    for func in ('_getpty', 'acosh', 'alarm', 'asinh', 'atanh', 'bind_textdomain_codeset', 'chflags', 'chown', 'chroot',
                 'clock', 'confstr', 'copysign', 'ctermid', 'ctermid_r', 'dlopen', 'dup2', 'epoll_create', 'erf',
                 'erfc', 'execv', 'expm1', 'fchdir', 'fchmod', 'fchown', 'finite', 'fork', 'forkpty',
                 'fpathconf', 'fseek64', 'fseeko', 'fstatvfs', 'fsync', 'ftell64', 'ftello', 'ftime', 'ftruncate',
                 'gai_strerror', 'gamma', 'getcwd', 'getgroups', 'gethostbyname', 'gethostbyname_r', 'getitimer',
                 'getloadavg', 'getlogin',
                 'getnameinfo', 'getpagesize', 'getpeername', 'getpgid', 'getpgrp', 'getpid', 'getpriority', 'getpwent',
                 'getresgid', 'getresuid', 'getsid', 'getspent', 'getspnam', 'gettimeofday', 'getwd', 'hstrerror',
                 'hypot', 'inet_aton', 'inet_pton', 'initgroups', 'is_term_resized', 'kill', 'killpg', 'lchflags',
                 'lchmod', 'lchown', 'lgamma', 'link', 'log1p', 'lstat', 'memmove', 'mkfifo', 'mknod', 'mktime',
                 'mremap', 'nice', 'openpty', 'pathconf', 'pause', 'plock', 'poll', 'pthread_atfork', 'pthread_init',
                 'pthread_sigmask', 'putenv', 'readlink', 'realpath', 'resize_term', 'resizeterm', 'round', 'select',
                 'sem_getvalue', 'sem_open', 'sem_timedwait', 'sem_unlink', 'setegid', 'seteuid', 'setgid', 'setgroups',
                 'setitimer', 'setlocale', 'setpgid', 'setpgrp', 'setregid', 'setresgid', 'setresuid', 'setreuid',
                 'setsid', 'setuid', 'setvbuf', 'sigaction', 'siginterrupt', 'sigrelse', 'snprintf', 'socketpair',
                 'statvfs', 'strdup', 'strftime', 'symlink', 'sysconf', 'tcgetpgrp', 'tcsetpgrp', 'tempnam', 'tgamma',
                 'timegm', 'times', 'tmpfile', 'tmpnam', 'tmpnam_r', 'truncate', 'uname', 'unsetenv', 'utimes', 'wait3',
                 'wait4', 'waitpid', 'wcscoll'):
        add_int_define(symbol_to_define(func), config.CheckFunc(func))

    # On OSX if you declare fdatasync it will successfully link(!) but the function doesn't really exist.
    if env['PLATFORM'] != 'darwin':
        add_int_define(symbol_to_define('fdatasync'), config.CheckFunc('fdatasync'))

    def check_dirent(key, header):
        if config.CheckHeader(header):
            # We have to use DIR* because scons' Conftest checks for (x*) and sizeof(x) but for DIR there's no
            # sizeof(DIR) since the type is partially defined.
            add_int_define(key, config.CheckType('DIR*', includes='#include <{}>'.format(header)))

    check_dirent('HAVE_DIRENT_H', 'dirent.h')
    check_dirent('HAVE_NDIR_H', 'ndir.h')
    check_dirent('HAVE_SYS_DIR_H', 'sys/dir.h')
    check_dirent('HAVE_SYS_NDIR_H', 'sys/ndir.h')

    add_int_define('HAVE_ALTZONE', config.CheckDeclaration('altzone', includes='#include <time.h>'))
    add_int_define('HAVE_ADDRINFO', config.CheckType('struct addrinfo', includes='#include <netdb.h>'))

    add_int_define('HAVE_C99_BOOL', config.CheckType('_Bool', includes=default_includes))
    add_int_define('HAVE_INT32_T', config.CheckType('int32_t', includes=default_includes))
    add_int_define('HAVE_UINT32_T', config.CheckType('uint32_t', includes=default_includes))
    add_int_define('HAVE_INT64_T', config.CheckType('int64_t', includes=default_includes))
    add_int_define('HAVE_UINT64_T', config.CheckType('uint64_t', includes=default_includes))
    add_int_define('HAVE_UINTPTR_T', config.CheckType('uintptr_t', includes=default_includes))
    add_int_define('HAVE_SSIZE_T', config.CheckType('ssize_t', includes=default_includes))
    add_int_define('HAVE_LONG_DOUBLE', config.CheckType('long double'))
    add_int_define('HAVE_LONG_LONG', config.CheckType('long long'))

    defines['SIZEOF_DOUBLE'] = config.CheckTypeSize('double')
    defines['SIZEOF_FLOAT'] = config.CheckTypeSize('float')
    defines['SIZEOF_FPOS_T'] = config.CheckTypeSize('fpos_t')
    defines['SIZEOF_INT'] = config.CheckTypeSize('int')
    defines['SIZEOF_LONG'] = config.CheckTypeSize('long')
    defines['SIZEOF_LONG_DOUBLE'] = config.CheckTypeSize('long double')
    defines['SIZEOF_LONG_LONG'] = config.CheckTypeSize('long long')
    defines['SIZEOF_OFF_T'] = config.CheckTypeSize('off_t')
    defines['SIZEOF_PID_T'] = config.CheckTypeSize('pid_t')
    defines['SIZEOF_PTHREAD_T'] = config.CheckTypeSize('pthread_t')
    defines['SIZEOF_SHORT'] = config.CheckTypeSize('short')
    defines['SIZEOF_SIZE_T'] = config.CheckTypeSize('size_t')
    defines['SIZEOF_TIME_T'] = config.CheckTypeSize('time_t')
    defines['SIZEOF_UINTPTR_T'] = config.CheckTypeSize('uintptr_t', includes=default_includes)
    defines['SIZEOF_VOID_P'] = config.CheckTypeSize('void *')
    defines['SIZEOF_WCHAR_T'] = config.CheckTypeSize('wchar_t',
                                                     includes="#include <wchar.h>" if 'HAVE_WCHAR_H' in defines else None)
    defines['SIZEOF__BOOL'] = config.CheckTypeSize('_Bool')

    if env['PLATFORM'] == 'aix':
      defines['HAVE_BROKEN_PIPE_BUF'] = 1

    add_int_define('HAVE_BROKEN_NICE', check_nice_broken(config))
    add_int_define('HAVE_BROKEN_POLL', check_poll_broken(config))


# /* Define if `unsetenv` does not return an int. */
# #undef HAVE_BROKEN_UNSETENV

    add_int_define('HAVE_BROKEN_SEM_GETVALUE', not check_working_sem_getvalue(config))

    defines['HAVE_DECL_ISFINITE'] = 1 if config.CheckDeclaration('isfinite', includes='#include <math.h>') else 0
    defines['HAVE_DECL_ISINF'] = 1 if config.CheckDeclaration('isinf', includes='#include <math.h>') else 0
    defines['HAVE_DECL_ISNAN'] = 1 if config.CheckDeclaration('isnan', includes='#include <math.h>') else 0
    add_int_define('HAVE_DECL_TZNAME', config.CheckDeclaration('tzname', includes='#include <time.h>'))
    add_int_define('HAVE_TZNAME', check_tzname(config))
    add_int_define('HAVE_DEV_PTC', config.CheckDeviceFile('/dev/ptc'))
    add_int_define('HAVE_DEV_PTMX', config.CheckDeviceFile('/dev/ptmx'))

    if 'PYTHON_DYNLOAD_FILE' in env:
      have_dynamic_loading = env['PYTHON_DYNLOAD_FILE'] != 'dynload_stub.c'
    else:
      have_dynamic_loading = env['PLATFORM'] in ('aix', 'beos', 'hp') or 'HAVE_DLOPEN' in defines

    add_int_define('HAVE_DYNAMIC_LOADING', have_dynamic_loading)

    add_int_define('HAVE_GCC_ASM_FOR_X87', check_gcc_asm_for_x87(config))

    add_int_define('HAVE_GETADDRINFO', check_getaddrinfo(config))
    if env['WITH_IPV6']:
        if 'HAVE_GETADDRINFO' not in defines:
            raise Exception("getaddrinfo() must be available to use IPv6")
        defines['ENABLE_IPV6'] = 1

    add_int_define('HAVE_GETC_UNLOCKED', check_getc_unlocked(config))

    add_int_define('HAVE_GETHOSTBYNAME_R_3_ARG', check_gethostbyname_r_3_arg(config));
    add_int_define('HAVE_GETHOSTBYNAME_R_5_ARG', check_gethostbyname_r_5_arg(config));
    add_int_define('HAVE_GETHOSTBYNAME_R_6_ARG', check_gethostbyname_r_6_arg(config));
    add_int_define('HAVE_KQUEUE', config.CheckDeclaration('kqueue',
                                                          includes='#include <sys/types.h>\n#include <sys/event.h>'))
    if env['WITH_DL']:
        defines['HAVE_LIBDL'] = 1

# /* Define to 1 if you have the `dld' library (-ldld). */
# #undef HAVE_LIBDLD

# /* Define to 1 if you have the `ieee' library (-lieee). */
# #undef HAVE_LIBIEEE

# /* Define to 1 if you have the `resolv' library (-lresolv). */
# #undef HAVE_LIBRESOLV

    if env['PLATFORM'] == 'darwin':
        add_int_define('HAVE_OSX105_SDK', check_osx_10_5_sdk(config))

    add_int_define('HAVE_PROTOTYPES', check_compiler_prototypes(config))

# /* Define if you have GNU PTH threads. */
# #undef HAVE_PTH

# /* Defined for Solaris 2.6 bug in pthread header. */
# #undef HAVE_PTHREAD_DESTRUCTOR

    if env['WITH_READLINE']:
        defines['HAVE_LIBREADLINE'] = 1
        # We can't use config.CheckDeclaration for some of these symbols because it's too strict - it checks for
        # rvalue and that can't compile if the symbol is an integer for example.
        add_int_define('HAVE_RL_CALLBACK',
                       confutils.check_symbol_declaration(config, 'rl_callback_handler_install', lib_name='readline'))
        add_int_define('HAVE_RL_CATCH_SIGNAL',
                       confutils.check_symbol_declaration(config, 'rl_catch_signals', lib_name='readline'))
        add_int_define('HAVE_RL_COMPLETION_APPEND_CHARACTER',
                       confutils.check_symbol_declaration(config, 'rl_completion_append_character', lib_name='readline'))
        add_int_define('HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK',
                       confutils.check_symbol_declaration(config, 'rl_completion_display_matches_hook', lib_name='readline'))
        add_int_define('HAVE_RL_COMPLETION_MATCHES',
                       confutils.check_symbol_declaration(config, 'rl_completion_matches', lib_name='readline'))
        add_int_define('HAVE_RL_COMPLETION_SUPPRESS_APPEND',
                       confutils.check_symbol_declaration(config, 'rl_completion_suppress_append', lib_name='readline'))
        add_int_define('HAVE_RL_PRE_INPUT_HOOK',
                       confutils.check_symbol_declaration(config, 'rl_pre_input_hook', lib_name='readline'))

    add_int_define('HAVE_SOCKADDR_SA_LEN',
                   config.CheckCStructMember(['sys/types.h', 'sys/socket.h'], 'sockaddr', 'sa_len'))

    add_int_define('HAVE_SOCKADDR_STORAGE', config.CheckType('struct sockaddr_storage', includes='#include <sys/socket.h>'))

    add_int_define('HAVE_STAT_TV_NSEC', config.CheckCStructMember('sys/stat.h', 'stat', 'st_mtim.tv_nsec'))
    add_int_define('HAVE_STAT_TV_NSEC2', config.CheckCStructMember('sys/stat.h', 'stat', 'st_mtimespec.tv_nsec'))

    add_int_define('HAVE_STDARG_PROTOTYPES', check_stdarg_prototypes(config))

    add_int_define('HAVE_STRUCT_STAT_ST_BIRTHTIME', config.CheckCStructMember(default_headers, 'stat', 'st_birthtime'))
    add_int_define('HAVE_STRUCT_STAT_ST_BLKSIZE', config.CheckCStructMember(default_headers, 'stat', 'st_blksize'))
    add_int_define('HAVE_STRUCT_STAT_ST_BLOCKS', config.CheckCStructMember(default_headers, 'stat', 'st_blocks'))
    if 'HAVE_STRUCT_STAT_ST_BLOCKS' in defines:
        defines['HAVE_ST_BLOCKS'] = 1
    add_int_define('HAVE_STRUCT_STAT_ST_FLAGS', config.CheckCStructMember(default_headers, 'stat', 'st_flags'))
    add_int_define('HAVE_STRUCT_STAT_ST_GEN', config.CheckCStructMember(default_headers, 'stat', 'st_gen'))
    add_int_define('HAVE_STRUCT_STAT_ST_RDEV', config.CheckCStructMember(default_headers, 'stat', 'st_rdev'))

    add_int_define('HAVE_UCS4_TCL', check_ucs4_tcl(config))

    add_int_define('HAVE_WORKING_TZSET', check_working_tzset(config))

    add_int_define('HAVE_ZLIB_COPY', confutils.check_symbol_declaration(config, 'inflateCopy', lib_name='zlib'))

    def check_makedev_and_device_macros():
        code = "#include <sys/types.h>\nint main () { return makedev(0, 0); }"
        devices_header = None
        if config.CheckCLinks("Checking if makedev is defined sys/types ...", code):
            devices_header = 'sys/types.h'
        else:
            if config.CheckDeclaration("major", includes="#include <sys/mkdev.h>"):
                defines['MAJOR_IN_MKDEV'] = 1
                devices_header = 'sys/mkdev.h'
            elif config.CheckDeclaration("major", includes="#include <sysmacros.h>"):
                defines["MAJOR_IN_SYSMACROS"] = 1
                devices_header = 'sysmacros.h'

        if devices_header:
            code = "#include <%(devices_header)s>\nint main() {\nmakedev(major(0),minor(0));return 0;}" % dict(devices_header=devices_header)
            add_int_define('HAVE_DEVICE_MACROS', config.CheckCCompiles('Checking if we have device macros... ', code))

            # Now we try to link w/ makedev and see if that works:
            code = "#include <%(devices_header)s>\nint main() {\nmakedev(0, 0);return 0;}" % dict(devices_header=devices_header)
            if config.CheckCLinks('Checking if we have makedev... ', code):
                defines['HAVE_MAKEDEV'] = 1
            else:
                code = "#define _OSF_SOURCE 1\n" + code
                if config.CheckCLinks('Checking if _OSF_SOURCE enabled makedev... ', code):
                    defines['HAVE_MAKEDEV'] = 1
                    defines['_OSF_SOURCE'] = 1

    check_makedev_and_device_macros()

# /* Define to the address where bug reports for this package should be sent. */
# #undef PACKAGE_BUGREPORT

# /* Define to the full name of this package. */
# #undef PACKAGE_NAME

# /* Define to the full name and version of this package. */
# #undef PACKAGE_STRING

# /* Define to the one symbol short name of this package. */
# #undef PACKAGE_TARNAME

# /* Define to the home page for this package. */
# #undef PACKAGE_URL

# /* Define to the version of this package. */
# #undef PACKAGE_VERSION

# /* Define if POSIX semaphores aren't enabled on your system */
# #undef POSIX_SEMAPHORES_NOT_ENABLED

# /* Define as the preferred size in bits of long digits */
# #undef PYLONG_BITS_IN_DIGIT

    defines['PY_FORMAT_LONG_LONG'] = '"ll"'
    defines['PY_FORMAT_SIZE_T'] = '"z"'


    def check_unicode_support(unicode_size):
        defines['Py_USING_UNICODE'] = 1
        defines['Py_UNICODE_SIZE'] = unicode_size

        wchar_size = defines.get('SIZEOF_WCHAR_T', 0)

        code = """
%(headers)s
int main() {
    /* Success: exit code 0 */
    exit((((wchar_t) -1) < ((wchar_t) 0)) ? 0 : 1);
}
"""
        code = code % dict(headers='#include <wchar.h>' if 'HAVE_WCHAR_H' in defines else '')
        wchar_signed = config.CheckCRuns('Checking if wchar_t is signed... ', code)

        if wchar_size == defines['Py_UNICODE_SIZE'] and not wchar_signed:
            defines['HAVE_USABLE_WCHAR_T'] = 1
            defines['PY_UNICODE_TYPE'] = 'wchar_t'
        elif defines['SIZEOF_SHORT'] == defines['Py_UNICODE_SIZE']:
            defines['PY_UNICODE_TYPE'] = 'unsigned short'
        elif defines['SIZEOF_LONG'] == defines['Py_UNICODE_SIZE']:
            defines['PY_UNICODE_TYPE'] = 'unsigned long'
        else:
            raise Exception("failed to find suitable type for unicode support")

    if env['WITH_UNICODE']:
        check_unicode_support(int(env['UNICODE_SIZE']))

    if env['WITH_PYDEBUG']:
        defines['Py_DEBUG'] = 1

    if env['WITH_SHARED']:
        defines['Py_ENABLE_SHARED'] = 1

    defines['RETSIGTYPE'] = 'void'

    add_int_define('SETPGRP_HAVE_ARG', check_setpgrp_have_arg(config))

# /* Define if i>>j for signed int i does not extend the sign bit when i < 0 */
# #undef SIGNED_RIGHT_SHIFT_ZERO_FILLS

    add_int_define('SYS_SELECT_WITH_SYS_TIME', check_sys_select_with_sys_time_is_ok(config))

    add_int_define('TANH_PRESERVES_ZERO_SIGN', check_tanh_preserves_zero_sign(config))

    add_int_define('TIME_WITH_SYS_TIME', check_time_with_sys_time_is_ok(config))

    tm_header = "time.h" if config.CheckType('struct tm', includes='#include <time.h>') else "sys/time.h"
    if tm_header == "sys/time.h":
        defines['TM_IN_SYS_TIME'] = 1

    if config.CheckCStructMember(default_headers + [tm_header], 'tm', 'tm_zone'):
        defines['HAVE_STRUCT_TM_TM_ZONE'] =1
        defines['HAVE_TM_ZONE'] = 1

# /* Define if you want to use MacPython modules on MacOSX in unix-Python. */
# #undef USE_TOOLBOX_OBJECT_GLUE

    add_int_define('VA_LIST_IS_ARRAY', check_va_list_is_array(config))


# /* Define if you want SIGFPE handled (see Include/pyfpe.h). */
# #undef WANT_SIGFPE_HANDLER

# /* Define if you want wctype.h functions to be used instead of the one
#    supplied by Python itself. (see Include/unicodectype.h). */
# #undef WANT_WCTYPE_FUNCTIONS

    code = "#include <curses.h>\nint main() { int rtn; rtn = mvwdelch(0,0,0); return rtn; }"
    add_int_define('MVWDELCH_IS_EXPRESSION',
                   config.CheckCCompiles('Checking if mvwdelch in curses.h is an expression... ', code))

    code = "#include <curses.h>\nint main() { WINDOW *w; w->_flags = 0; return 0; }"
    add_int_define('WINDOW_HAS_FLAGS', config.CheckCCompiles("Checking if curses WINDOW has _flags... ", code))

    if env['WITH_DOC_STRINGS']:
        defines['WITH_DOC_STRINGS'] = 1

# /* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic
#    linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).
#    Dyld is necessary to support frameworks. */
# #undef WITH_DYLD

# /* Define to 1 if libintl is needed for locale functions. */
# #undef WITH_LIBINTL

# /* Define if you want to produce an OpenStep/Rhapsody framework (shared
#    library plus accessory files). */
# #undef WITH_NEXT_FRAMEWORK

    if env['WITH_PYMALLOC']:
        defines['WITH_PYMALLOC'] = 1
        if env['WITH_VALGRIND']:
            defines['WITH_VALGRIND'] = 1

    if env['WITH_THREAD']:
        # FIXME: for now assume only POSIX threads.
        defines['WITH_THREAD'] = 1
        defines['_POSIX_PTHREAD_SEMANTICS'] = 1
        # FIXME: check if these are automatically defined:

        # TODO There's a lot of code in configure.ac to try and figure out which threads mechanism is used for the
        # platform, and based on that whether or not to force _REENTRANT.
        # Later we may copy the logic here, but for now we'll do it per platform.
        if env['PLATFORM'] == 'darwin':
            defines['_REENTRANT'] = 1
        #defines['_POSIX_THREADS'] = 1

        # #undef HURD_C_THREADS
        # #undef MACH_C_THREADS

        if env['PLATFORM'] == 'sunos' and env['PLATFORM_RELEASE'] == '5.6':
            defines['HAVE_PTHREAD_DESTRUCTOR'] = 1

        if (env['PLATFORM'] == 'sunos' and env['PLATFORM_RELEASE'] == '5.8') or env['PLATFORM']== 'aix':
            defines['HAVE_BROKEN_POSIX_SEMAPHORES'] = 1

        # According to the POSIX spec, a pthreads implementation must
        # define _POSIX_THREADS in unistd.h. Some apparently don't
        # (e.g. gnu pth with pthread emulation)
        unistd_defines_pthreads = config.CheckDeclaration('_POSIX_THREADS', includes='#include <unistd.h>')
        if not unistd_defines_pthreads:
            pass

        if check_pthread_scope_system_supported(config):
            defines['PTHREAD_SYSTEM_SCHED_SUPPORTED'] = 1

        if env['PLATFORM']== 'cygwin':
            defines['HAVE_BROKEN_PTHREAD_SIGMASK'] = 1

        if env['WITH_TSC']:
            defines['WITH_TSC'] = 1

# /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
#    significant byte first (like Motorola and SPARC, unlike Intel). */
# #if defined AC_APPLE_UNIVERSAL_BUILD
# # if defined __BIG_ENDIAN__
# #  define WORDS_BIGENDIAN 1
# # endif
# #else
# # ifndef WORDS_BIGENDIAN
# #  undef WORDS_BIGENDIAN
# # endif
# #endif

    add_int_define('X87_DOUBLE_ROUNDING', check_x87_double_rounding(config))

# /* This must be set to 64 on some systems to enable large file support. */
# #undef _FILE_OFFSET_BITS
    def check_large_file_support():
        if defines['SIZEOF_OFF_T'] > defines['SIZEOF_LONG'] and defines['SIZEOF_LONG_LONG'] >= defines['SIZEOF_OFF_T']:
            defines['HAVE_LARGEFILE_SUPPORT'] = 1

        if check_solaris_lfs_no_bug(config):
            # TODO: on AIX add: defines['_LARGE_FILES'] = 1
            defines['_LARGEFILE_SOURCE'] = 1
            defines['_FILE_OFFSET_BITS'] = 64

    check_large_file_support()


# /* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
#    <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
#    #define below would cause a syntax error. */
# #undef _UINT32_T

# /* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
#    <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
#    #define below would cause a syntax error. */
# #undef _UINT64_T

    # FIXME there are platforms where it's not _XOPEN_SOURCE / POSIX / etc. We currently don't support them.
    defines['_GNU_SOURCE'] = 1
    defines['_ALL_SOURCE'] = 1
    defines['_TANDEM_SOURCE'] = 1

    if check_safe_to_define__extensions__(config, default_includes):
        defines['__EXTENSIONS__'] = 1

    if not (env['PLATFORM'] in 'darwin'):
        defines['_XOPEN_SOURCE'] = 600
        defines['_XOPEN_SOURCE_EXTENDED'] = 1
        defines['_POSIX_C_SOURCE'] = '200112L'

    defines['__BSD_VISIBLE'] = 1
    # defines['_BSD_SOURCE'] = 1
    defines['_BSD_TYPES'] = 1
    defines['_DARWIN_C_SOURCE'] = 1
    defines['_NETBSD_SOURCE'] = 1
    defines['STDC_HEADERS'] = 1
    defines['SHLIB_EXT'] = '"{}"'.format(env['SHLIBSUFFIX'])

    add_int_define('__CHAR_UNSIGNED__', check_char_unsigned(config))


    if not config.CheckType('clock_t', includes='#include <time.h>'):
        defines['clock_t'] = 'long'

    if not check_ansi_c_conforming_const(config):
        defines['const'] = '/**/'

    if not config.CheckType('gid_t', includes='#include <sys/types.h>'):
        defines['gid_t'] = 'int'

# /* Define to the type of a signed integer type of width exactly 32 bits if
#    such a type exists and the standard includes do not define it. */
# #undef int32_t

# /* Define to the type of a signed integer type of width exactly 64 bits if
#    such a type exists and the standard includes do not define it. */
# #undef int64_t

# /* Define to `int' if <sys/types.h> does not define. */
# #undef mode_t

# /* Define to `long int' if <sys/types.h> does not define. */
# #undef off_t

# /* Define to `int' if <sys/types.h> does not define. */
# #undef pid_t

# /* Define to empty if the keyword does not work. */
# #undef signed

# /* Define to `unsigned int' if <sys/types.h> does not define. */
# #undef size_t

# /* Define to `int' if <sys/socket.h> does not define. */
# #undef socklen_t

# /* Define to `int' if <sys/types.h> doesn't define. */
# #undef uid_t

# /* Define to the type of an unsigned integer type of width exactly 32 bits if
#    such a type exists and the standard includes do not define it. */
# #undef uint32_t

# /* Define to the type of an unsigned integer type of width exactly 64 bits if
#    such a type exists and the standard includes do not define it. */
# #undef uint64_t

    if not check_volatile(config):
        defines['volatile'] = '/**/'

    # TODO: we need to:
    # 1. check if we're using gcc
    # 2. add -Werror and -Wformat to the CFLAGS in this compilation
    # code = "void f(char*,...)__attribute((format(PyArg_ParseTuple, 1, 2)));\nint main() { return 0; }"
    # add_int_define('HAVE_ATTRIBUTE_FORMAT_PARSETUPLE',
    #                config.CheckCCompiles('Checking whether gcc supports ParseTuple __format__... ', code))

    configured_env = config.Finish()
    return (configured_env, defines)


def configure_win32():
    return env, dict()


if is_building():
    if env['PLATFORM'] != 'win32':
        env, pyconfig_defines = configure()
    else:
        env, pyconfig_defines = configure_win32()
    def show_configure(*args, **kwargs):
      import pprint
      pprint.pprint(pyconfig_defines)
    env.AlwaysBuild(env.Alias('show_configure', [], show_configure))
else:
    pyconfig_defines = dict()  # Just so we'll have something

Return('env pyconfig_defines')